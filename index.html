<!doctype html>
<html>

<head>
  <title>DCL Loader</title>
<style>
body {
  margin: 0;
}
canvas {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  outline: none;
}
</style>
</head>
<body>
<script type=module>
import * as THREE from 'https://app.webaverse.com/three.module.js';
import {GLTFLoader} from 'https://app.webaverse.com/GLTFLoader.js';
import {OrbitControls} from 'https://app.webaverse.com/OrbitControls.js';
import {getBasisTransform, axesToAsciiImage, stringToAxes} from './basis.js';

const inversionMatrix = new THREE.Matrix4();
/* const unityTransform = */getBasisTransform('-X+Y+Z', '+X+Y+Z', inversionMatrix);
// console.log('inversion', inversionMatrix);
// const inversionMatrix = new THREE.Matrix4().fromArray([-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

const _getTiles = async () => {
  const res = await fetch('https://api.decentraland.org/v1/tiles');
  const j = await res.json();
  const {data} = j;
  return data;
};
const _getCoord = async (x, z) => {
  const res = await fetch('https://peer-ec1.decentraland.org/content/entities/scene?pointer=' + [x,z].join(','));
  const j = await res.json();
  return j[0];
};

(async () => {
  const _getTilesCanvas = async () => {
    const tiles = await _getTiles();
    console.log('got tiles', tiles);
    const canvas = document.createElement('canvas');
    const size = 301*10;
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = '#18141a';
    ctx.fillRect(0, 0, size, size);
    // document.body.appendChild(canvas);
    
    ctx.fillStyle = '#3d3a46';
    
    const _snap = n => n;//Math.floor(n);

    const boxSize = size/301;
    for (let x = -150; x <= 150; x++) {
      for (let z = -150; z <= 150; z++) {
        // ctx.fillStyle = '#3d3a46';
        ctx.fillRect(_snap(boxSize*(x+150) + boxSize*0.1), _snap(boxSize*(z+150) + boxSize*0.1), _snap(boxSize*0.8), _snap(boxSize*0.8));
        const tile = tiles[[x,-z].join(',')];
        let {top, left, topLeft} = tile;
        // topLeft = false;
        if (top) {
          ctx.fillRect(_snap(boxSize*(x+150) + boxSize*0.1), _snap(boxSize*(z+150) - boxSize*0.1), _snap(boxSize*0.8), _snap(boxSize*0.2));
        }
        if (left) {
          ctx.fillRect(_snap(boxSize*(x+150) - boxSize*0.1), _snap(boxSize*(z+150) + boxSize*0.1), _snap(boxSize*0.2), _snap(boxSize*0.8));
        }
        if (left && top && topLeft) {
          // ctx.fillStyle = '#FF0000';        
          ctx.fillRect(_snap(boxSize*(x+150) - boxSize*0.1), _snap(boxSize*(z+150) - boxSize*0.1), _snap(boxSize*0.2), _snap(boxSize*0.2));
        }
      }
    }
    return canvas;
  };
  const tilesCanvas = await _getTilesCanvas();

  const coord = await _getCoord(21, 34);
  const {metadata: {main}, content} = coord;
  console.log('loaded', coord);
  const mainFile = content.find(f => f.file === main);
  const {hash} = mainFile;

  const worker = new Worker('./worker.js?hash=' + hash);
  worker.onmessage = async e => {
    const j = JSON.parse(e.data);
    worker.terminate();

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', e => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });

    const scene = new THREE.Scene();
    scene.matrix.copy(inversionMatrix)
      .decompose(scene.position, scene.quaternion, scene.scale);
    window.scene = scene;

    const camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 300);
    camera.position.set(0, 10, -10);
    camera.lookAt(new THREE.Vector3());

    const ambientLight = new THREE.AmbientLight(0x808080);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
    directionalLight.position.set(1, 2, 3);
    scene.add(directionalLight);

    const orbitControls = new OrbitControls(camera, renderer.domElement);
    orbitControls.screenSpacePanning = true;
    orbitControls.enableMiddleZoom = false;
    // orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, camera.position.y, -3).applyQuaternion(camera.quaternion));
    orbitControls.update();
    
    renderer.setAnimationLoop(() => {
      orbitControls.update();
      renderer.render(scene, camera);
    });
    
    const floorMesh = (() => {
      const geometry = new THREE.PlaneBufferGeometry(301*16, 301*16)
        .applyMatrix4(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2)));
      const texture = new THREE.Texture(tilesCanvas);
      texture.needsUpdate = true;
      const material = new THREE.MeshBasicMaterial({
        map: texture,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.y = -0.1;
      mesh.frustumCulled = false;
      return mesh;
    })();
    scene.add(floorMesh);

    const manager = new THREE.LoadingManager();
    manager.setURLModifier(url => {
      // const u = (() => {
        if (url.includes('https://peer-ec1.decentraland.org/lambdas/contentv2/contents/Q')) {
          return url;
        } else {
          const u = 'unity_assets/' + url.slice('https://peer-ec1.decentraland.org/lambdas/contentv2/contents/'.length);
          const file = content.find(f => f.file === u);
          if (file) {
            const {hash} = file;
            return 'https://peer-ec1.decentraland.org/lambdas/contentv2/contents/' + hash;
          } else {
            console.warn('content not found', url);
            return url;
          }
        }
      // })();
      // console.log('load', [url, u]);
      // return u;
    });
    const _loadGltf = async u => {
      let o = await new Promise((accept, reject) => {
        new GLTFLoader(manager).load(u, accept, function onprogress() {}, reject);
      });
      o = o.scene;
      return o;
    };
    const _loadGltfCached = (() => {
      const cache = {};
      return async u => {
        let entry = cache[u];
        if (!entry) {
          entry = await _loadGltf(u);
          cache[u] = entry;
        }
        return entry.clone();
      };
    })();

    const entities = {};
    const components = {};

    for (const entry of j.result) {
      const {method, args} = entry;
      console.log('got method', method, args);
      switch (method) {
        case 'addEntity': {
          const [id] = args;
          const entity = new THREE.Object3D();
          entity.components = [];
          if (id === '0') {
            scene.add(entity);
          }
          entities[id] = entity;
          break;
        }
        case 'setParent': {
          const [id, parentId] = args;
          const entity = entities[id];
          const parent = entities[parentId];
          parent.add(entity);
          break;
        }
        case 'updateEntityComponent': {
          const [id, template, id2, s] = args;
          const entity = entities[id];
          switch (template) {
            case 'engine.transform': {
              // if (id === 'Eq') continue;
              const j = JSON.parse(s);
              const {position, rotation, scale} = j;
              // console.log('got transform', j);
              /* const {y, z} = position;
              position.z = y;
              position.y = z; */
              // position.x *= -1;
              // position.z *= -1;
              // position.y *= -1;
              // scale.y *= -1;
              entity.position.copy(position);
              /* if (position.y < 0) {
                position.y *= -1;
                scale.y *= -1;
                // console.log('less than', id);
              } */
              entity.quaternion.copy(rotation)
                // .conjugate()
                // .normalize()
                // .multiply(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, -1)));
              // convert Quaternion from Left-handed coordinate system to Right-handed
              /* {
                var q = new THREE.Quaternion(-rotation.x, rotation.y, rotation.z, -rotation.w);

                var v = new THREE.Euler().setFromQuaternion(q);

                v.y += Math.PI; // Y is 180 degrees off

                v.z *= -1; // flip Z

                entity.quaternion.set(rotation.z, rotation.w, rotation.x, rotation.y);
              } */
              entity.scale.copy(scale);
              // entity.updateMatrixWorld();
              entity.matrix
                .compose(entity.position, entity.quaternion, entity.scale)
                // .premultiply(inversionMatrix)
                .decompose(entity.position, entity.quaternion, entity.scale);
              break;
            }
            default: {
              console.warn('unknown component template', template);
              break;
            }
          }
          break;
        }
        case 'componentCreated': {
          const [id, template, id2] = args;
          const component = {
            template,
          };
          components[id] = component;
          break;
        }
        case 'componentUpdated': {
          const [id, s] = args;
          const j = JSON.parse(s);
          const component = components[id];
          component.data = j;
          break;
        }
        case 'attachEntityComponent': {
          const [entityId, template, componentId] = args;
          const entity = entities[entityId];
          const component = components[componentId];
          switch (template) {
            case 'engine.shape': {
              entity.components.push(component);
              break;
            }
            default: {
              console.warn('unknown component template', template);
              break;
            }
          }
          break;
        }
        default: {
          console.warn('unknown method', method);
          break;
        }
      }
    }

    for (const id in entities) {
      const entity = entities[id];
      /* if (entity.components.length === 0) {
        entity.position.set(0, 0, 0);
        entity.quaternion.set(0, 0, 0, 1);
        entity.scale.set(1, 1, 1);
      } */
      for (const component of entity.components) {
        const {data} = component;
        const {src, visible} = data;
        if (src && visible) {
          if (/\.(?:glb|gltf)$/.test(src)) {
            const srcFile = content.find(f => f.file === src);
            if (srcFile) {
              const {hash} = srcFile;
              try {
                let model = await _loadGltfCached('https://peer-ec1.decentraland.org/lambdas/contentv2/contents/' + hash);
                console.log('got model', id, model);
                // model.rotation.z += Math.PI;
                // const box = new THREE.Box3().setFromObject(model);
                // model.position.sub(box.getCenter(new THREE.Vector3()));
                model.matrix.copy(inversionMatrix)
                  .decompose(model.position, model.quaternion, model.scale);
                model.traverse(o => {
                  if (o.isMesh && /_collider/.test(o.name)) {
                    o.visible = false;
                  }
                });
                entity.add(model);
              } catch (err) {
                console.warn(err);
              }
            } else {
              console.warn('content file not found', srcFile);
            }
          } else {
            console.warn('illegal engine file', src);
          }
        } else {
          console.warn('shape with no src', entity, component);
        }
      }
    }

    console.log('done');
  };
})();
</script>
</body>

</html>
